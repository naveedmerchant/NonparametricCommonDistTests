unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(mixturenormdraw)
var(unifdraw)
set.seed(1000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(mixturenormdraw)
var(normdraw)
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(normdraw)
var(mixturenormdraw)
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
ExpectedKernML <- logmarg.kern(XT1,XV1)
FullKernML <- logmarg.kern(c(XT1,XT2),XV1)
LBF[D] <- FullKernML[[2]] - ExpectedKernML[[2]]
logmarg.kern=function(y,x,prior=1){
out=optim(.4,loglike.KGauss,method="L-BFGS-B",lower=.0001,upper=5,y=y,x=x)
h=out$par
cons=-out$val
stat=integrate(integrand.Gauss,lower=0.0001,upper=5,y=y,x=x,cons=cons,prior=prior)$val
list(h,cons+log(stat))
}
loglike.KGauss=function(h,y,x){
n=length(x)
m=length(y)
nh=length(h)
M=t(matrix(y,m,n))
llike=1:nh
for(j in 1:nh){
M1=(x-M)/h[j]
M1=dnorm(M1)/h[j]
fhat=as.vector(M1 %*% matrix(1,m,1))/m
fhat[fhat<10^(-320)]=10^(-320)
llike[j]=sum(log(fhat))
}
-llike
}
integrand.Gauss=function(h,y,x,cons,prior){
n=length(x)
R=quantile(y,probs=c(.25,.75))
R=R[2]-R[1]
beta=R/1.35
beta1=beta*log(2)/sqrt(qgamma(.5,.5,1))
Prior=beta1*exp(-beta1/h)/h^2
if(prior==1) Prior=(2*beta/sqrt(pi))*h^(-2)*exp(-beta^2/h^2)
arg=-loglike.KGauss(h,y,x)-cons
arg[arg>700]=700
f=exp(arg)*Prior
f
}
ExpectedKernML <- logmarg.kern(XT1,XV1)
FullKernML <- logmarg.kern(c(XT1,XT2),XV1)
LBF[D] <- FullKernML[[2]] - ExpectedKernML[[2]]
ExpectedKernML <- logmarg.kern(XT1,XV1)
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)
ExpectedKernML2 <- logmarg.kern(XT2,XV2)
ExpectedKernML
ExpectedKernML2
knitr::opts_chunk$set(echo = TRUE)
library(matrixStats)
set.seed(500)
dataset<- rnorm(500)
X1 <- dataset[1:(length(dataset)*.3)]
X2 <- dataset[-(1:(length(dataset)*.3))]
B <- unname((quantile(X2,probs = .75) - quantile(X2,probs = .25))/1.35)
k <- length(X1)
n <- length(X2)
loglike.KGauss=function(h,y,x){
n=length(x)
m=length(y)
nh=length(h)
M=t(matrix(y,m,n))
llike=1:nh
for(j in 1:nh){
M1=(x-M)/h[j]
M1=dnorm(M1)/h[j]
fhat=as.vector(M1 %*% matrix(1,m,1))/m
fhat[fhat<10^(-320)]=10^(-320)
llike[j]=sum(log(fhat))
}
-llike
}
integrand.Gauss=function(h,y,x,cons,prior){
n=length(x)
R=quantile(y,probs=c(.25,.75))
R=R[2]-R[1]
beta=R/1.35
beta1=beta*log(2)/sqrt(qgamma(.5,.5,1))
Prior=beta1*exp(-beta1/h)/h^2
if(prior==1) Prior=(2*beta/sqrt(pi))*h^(-2)*exp(-beta^2/h^2)
arg=-loglike.KGauss(h,y,x)-cons
arg[arg>700]=700
f=exp(arg)*Prior
f
}
logmarg.kern=function(y,x,prior=1){
out=optim(.4,loglike.KGauss,method="L-BFGS-B",lower=.0001,upper=5,y=y,x=x)
h=out$par
cons=-out$val
stat=integrate(integrand.Gauss,lower=0.0001,upper=5,y=y,x=x,cons=cons,prior=prior)$val
list(h,cons+log(stat))
}
Loglist2 <- c()
logmarg.kern(X1,X2,prior=1)
for(K in 1:50)
{
sum1list <- c()
iter <- 1000
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2sum[[2]] - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) -log(iter)
Loglist2[K] <-  logMCinteg
}
X1
X2
k
n
X1
l
sum1 <- sum((X2sum[[l]] - X1)^2)
X2[l]
X2
length(l)
l
X1[l]
Loglist2 <- c()
logmarg.kern(X1,X2,prior=1)
for(K in 1:50)
{
sum1list <- c()
iter <- 1000
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) -log(iter)
Loglist2[K] <-  logMCinteg
}
summary(Loglist2)
plot(Loglist2)
length(X1)
n
k
logmarg.kernMC=function(X1,X2,iter = 10000)
{
require(matrixStats)
n <- length(X2)
k <- length(X1)
sum1 <- c()
sum1list <- c()
R = quantile(X1,probs=c(.25,.75))
B = R / 1.35
#browser()
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) - log(iter)
return(logMCinteg)
}
logmarg.kernMC(X1,X2,iter = 10000)
warnings()
logmarg.kernMC(X1,X2,iter = 10000)
logmarg.kernMC=function(X1,X2,iter = 10000)
{
require(matrixStats)
n <- length(X2)
k <- length(X1)
sum1 <- c()
sum1list <- c()
R = quantile(X1,probs=c(.25,.75))
B = R / 1.35
browser()
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) - log(iter)
return(logMCinteg)
}
logmarg.kernMC(X1,X2,iter = 10000)
i < 1
i <- 1
l <- sample(1:k,n, replace = TRUE)
l
sum1 <- sum((X2 - X1[l])^2)
sum1
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1
R
logmarg.kernMC=function(X1,X2,iter = 10000)
{
require(matrixStats)
n <- length(X2)
k <- length(X1)
sum1 <- c()
sum1list <- c()
R = quantile(X1,probs=c(.25,.75))
R=R[2]-R[1]
B = R / 1.35
#browser()
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) - log(iter)
return(logMCinteg)
}
logmarg.kernMC(X1,X2,iter = 10000)
logmarg.kernMC(X1,X2,iter = 10000)
logmarg.kernMC(X1,X2,iter = 10000)
type(logmarg.kernMC())
type(logmarg.kernMC(X1,X2,iter=1000))
typeof(logmarg.kernMC(X1,X2,iter=1000))
logmarg.kernMC=function(X1,X2,iter = 10000)
{
require(matrixStats)
n <- length(X2)
k <- length(X1)
sum1 <- c()
sum1list <- c()
R = quantile(X1,probs=c(.25,.75))
R=R[2]-R[1]
R = unname(R)
B = R / 1.35
#browser()
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) - log(iter)
return(logMCinteg)
}
logmarg.kernMC(X1,X2,iter = 10000)
logmarg.kernMC=function(X1,X2,iter = 10000)
{
require(matrixStats)
n <- length(X2)
k <- length(X1)
sum1 <- c()
sum1list <- c()
R = quantile(X1,probs=c(.25,.75))
R=R[2]-R[1]
R = unname(R)
B = R / 1.35
#browser()
for(i in 1:iter)
{
l <- sample(1:k,n, replace = TRUE)
sum1 <- sum((X2 - X1[l])^2)
sum1 <- lgamma((n-1)/2) - ((n-1)/2)*log(.5*(2*B^2 + sum1))
sum1list[i] <- sum1
}
logMCinteg <-log(B / sqrt(pi)) - (n/2)*log(2*pi) + logSumExp(sum1list) - log(iter)
return(logMCinteg)
}
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kern(XT1,XV1, iter = 10000) + logmarg.kern(XT2,XV2,iter = 10000)
RandkernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandkernML - RandKernML2
}
setwd("~/NonparametricCommonDistTests")
source("MarginalLikIntfunctions.R")
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kern(XT2,XV2,iter = 10000)
RandkernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandkernML - RandKernML2
}
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kernMC(XT2,XV2,iter = 10000)
RandkernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandkernML - RandKernML2
}
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kernMC(XT2,XV2,iter = 10000)
RandkernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandKernML - RandKernML2
}
#install.packages("rmutil")
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kernMC(XT2,XV2,iter = 10000)
RandKernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandKernML - RandKernML2
}
summary(LBF)
summary(LBF2)
logmarg.kernMC(XT1,XV1, iter = 10000)
logmarg.kern(XT1,XV1)[[2]]
plot(LBF)
plot(LBF2)
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
LBF2 <- c()
for(i in 1:100)
{
dataset1 <- rnorm(dlength)
dataset2 <- rnorm(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kernMC(XT2,XV2,iter = 10000)
RandKernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandKernML - RandKernML2
}
summary(LBF)
summary(LBF2)
plot(LBF)
plot(LBF2)
logmarg.kern(XT1,XV1)[[2]]
logmarg.kernMC(XT1,XV1, iter = 10000)
logmarg.kern(XT2,XV2)[[2]]
logmarg.kernMC(XT2,XV2,iter = 10000)
logmarg.kernMC(c(XT1,XT2),c(XV1,XV2))
logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
ExpectedKernML - ExpectedKernML2
RandKernML - RandKernML2
RandKernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2), iter = 10000)
RandKernML2
RandKernML - RandKernML2
ExpectedKernML - ExpectedKernML2
#install.packages("rmutil")
library(rmutil)
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 500
LBF <- c()
LBF2 <- c()
for(i in 1:30)
{
dataset1 <- rnorm(dlength)
dataset2 <- rnorm(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
RandKernML <- logmarg.kernMC(XT1,XV1, iter = 10000) + logmarg.kernMC(XT2,XV2,iter = 10000)
RandKernML2 <- logmarg.kernMC(c(XT1,XT2),c(XV1,XV2), iter = 10000)
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF2[i] <- RandKernML - RandKernML2
}
dataset1
dataset
cor(dataset,dataset
)
cor(dataset,1/dataset)
datasetsamp <- runif(1000)
datasetsamp <- 3 + runif(1000)
cor(datasetsamp,1/datasetsamp)
