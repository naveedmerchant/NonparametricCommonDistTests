{
sum <- sum + exp(-.5*((X2[j]-X1[i])/h)^2)
}
prod <- prod + log(sum) + log((1/sqrt(2*pi))) + log((k*h)^(-1))
}
return(prod)
}
Optimumbandwidthreg <- optimize(GaussKernLik, X1 = X1, X2 = X2, lower = .00001, upper = 5, maximum = TRUE, tol = .001)
Optimumaugbandwidthreg <- optimize(GaussKernLik, X1 = c(X1,Y1), X2 = c(X2,Y2), lower = .00001, upper = 5, maximum = TRUE, tol = .001)
#The questionable nature of how to split is why I believe the above step could be improved
BFPriorFree <- GaussKernLik(Optimumbandwidthreg$maximum,X1 = X1, X2 = X3) - GaussKernLik(Optimumaugbandwidthreg$maximum,X1 = c(X1,Y1), X2 = X3)
LBF[D] <- BFPriorFree
}
plot(LBF)
plot(XT1,1:150,col = "blue")
plot(XT1,1:150,col = "blue")
points(XT2,1:150,col = "red")
plot(XT1,1:150,col = "blue")
points(XT2,1:150,col = "red")
plot(XT2,1:150,col = "red")
plot(XT1,1:150,col = "blue")
points(XT2,1:150,col = "red")
knitr::opts_chunk$set(echo = TRUE)
library(EbayesThresh)
lambda2 <- .4
BR2 <- solve(t(Xvals)%*%Xvals + lambda2*diag(50))%*%(t(Xvals))%*%(Yvals)
Truebetas <- read.table("C:/Users/Naveed/Documents/TrueBeta.txt", header = FALSE)
Truebetas <- as.matrix(Truebetas)
Yvals <- read.table("C:/Users/Naveed/Documents/HW3X.txt", header = FALSE)
Yvals <- as.matrix(Yvals)
Xvals <- read.table("C:/Users/Naveed/Documents/HW3Y.txt", header = FALSE, sep = ",")
Xvals <- as.matrix(Xvals)
lambda <- seq(from = 0, to = 2, by = .01)
MSPE <- c()
for(i in 1:length(lambda))
{
BR <- solve(t(Xvals)%*%Xvals + lambda[i]*diag(50))%*%(t(Xvals))%*%(Yvals)
MSPE[i] <- sum((Xvals%*%BR - Xvals%*%Truebetas)^2)
}
plot(lambda,MSPE)
lambda2 <- .4
BR2 <- solve(t(Xvals)%*%Xvals + lambda2*diag(50))%*%(t(Xvals))%*%(Yvals)
BOLS <- solve(t(Xvals)%*%(Xvals))%*%(t(Xvals)%*%Yvals)
plot(Xvals%*%Truebetas, Xvals%*%BR2, col = "blue", ylab = "XB estimate" , xlab =  "XB true")
points(Xvals%*%Truebetas, Xvals%*%BOLS, col = "red")
knitr::opts_chunk$set(echo = TRUE)
library(matrixStats)
matrix(1,m,1)
?matrix
Loglist <- c()
cauchsamp<- rcauchy(500)
poscauchsamp <- cauchsamp[cauchsamp > 0]
importancepart <- ((2*B*(1/poscauchsamp^2)*(exp(-(B^2)/(poscauchsamp)^2)) / sqrt(pi))) / (2*dcauchy(poscauchsamp))
set.seed(500)
dataset<- rnorm(500)
X1 <- dataset[1:(length(dataset)*.3)]
X2 <- dataset[-(1:(length(dataset)*.3))]
set.seed(500)
dataset<- rnorm(500)
X1 <- dataset[1:(length(dataset)*.3)]
X2 <- dataset[-(1:(length(dataset)*.3))]
B <- unname((quantile(X2,probs = .75) - quantile(X2,probs = .25))/1.35)
k <- length(X1)
n <- length(X2)
cauchsamp<- rcauchy(500)
poscauchsamp <- cauchsamp[cauchsamp > 0]
importancepart <- ((2*B*(1/poscauchsamp^2)*(exp(-(B^2)/(poscauchsamp)^2)) / sqrt(pi))) / (2*dcauchy(poscauchsamp))
prodlist1<-c()
for(z in 1:length(poscauchsamp))
{
prod <- 0
for(j in 1:n)
{
sum <- 0
for(i in 1:k)
{
sum <- sum + exp(-.5*((X2[j]-X1[i])/poscauchsamp[z])^2)
}
prod <- prod + log(sum) + log((1/sqrt(2*pi))) - log((k*poscauchsamp[z]))
}
prodlist1[z] <- prod + log(importancepart[z])
}
prodlist1
log(sum(exp(prodlist1)))
prodlist1[prodlist1 < 10^(-320)] = 10^(-320)
log(sum(exp(prodlist1)))
prodlist1
for(z in 1:length(poscauchsamp))
{
prod <- 0
for(j in 1:n)
{
sum <- 0
for(i in 1:k)
{
sum <- sum + exp(-.5*((X2[j]-X1[i])/poscauchsamp[z])^2)
}
prod <- prod + log(sum) + log((1/sqrt(2*pi))) - log((k*poscauchsamp[z]))
}
prodlist1[z] <- prod + log(importancepart[z])
}
prodlist1[z]
prodlist1
prodlist1[prodlist1 < 10^(-320)]
length(prodlist1[prodlist1 < 10^(-320)])
length(prodlist1)
loglike.KGauss=function(h,y,x){
n=length(x)
m=length(y)
nh=length(h)
M=t(matrix(y,m,n))
llike=1:nh
for(j in 1:nh){
M1=(x-M)/h[j]
M1=dnorm(M1)/h[j]
fhat=as.vector(M1 %*% matrix(1,m,1))/m
#fhat[fhat<10^(-320)]=10^(-320)
llike[j]=sum(log(fhat))
}
-llike
}
integrand.Gauss=function(h,y,x,cons,prior){
n=length(x)
R=quantile(y,probs=c(.25,.75))
R=R[2]-R[1]
beta=R/1.35
beta1=beta*log(2)/sqrt(qgamma(.5,.5,1))
Prior=beta1*exp(-beta1/h)/h^2
if(prior==1) Prior=(2*beta/sqrt(pi))*h^(-2)*exp(-beta^2/h^2)
arg=-loglike.KGauss(h,y,x)-cons
arg[arg>700]=700
f=exp(arg)*Prior
f
}
logmarg.kern=function(y,x,prior=1){
out=optim(.4,loglike.KGauss,method="L-BFGS-B",lower=.0001,upper=5,y=y,x=x)
h=out$par
cons=-out$val
stat=integrate(integrand.Gauss,lower=0.0001,upper=5,y=y,x=x,cons=cons,prior=prior)$val
list(h,cons+log(stat))
}
#Code supplied by Dr. Hart
logmarg.kern(X1,X2,prior=1)
set.seed(500)
dataset<- rnorm(500)
X1 <- dataset[1:(length(dataset)*.3)]
X2 <- dataset[-(1:(length(dataset)*.3))]
B <- unname((quantile(X2,probs = .75) - quantile(X2,probs = .25))/1.35)
k <- length(X1)
n <- length(X2)
loglike.KGauss=function(h,y,x){
n=length(x)
m=length(y)
nh=length(h)
M=t(matrix(y,m,n))
llike=1:nh
for(j in 1:nh){
M1=(x-M)/h[j]
M1=dnorm(M1)/h[j]
fhat=as.vector(M1 %*% matrix(1,m,1))/m
fhat[fhat<10^(-320)]=10^(-320)
llike[j]=sum(log(fhat))
}
-llike
}
integrand.Gauss=function(h,y,x,cons,prior){
n=length(x)
R=quantile(y,probs=c(.25,.75))
R=R[2]-R[1]
beta=R/1.35
beta1=beta*log(2)/sqrt(qgamma(.5,.5,1))
Prior=beta1*exp(-beta1/h)/h^2
if(prior==1) Prior=(2*beta/sqrt(pi))*h^(-2)*exp(-beta^2/h^2)
arg=-loglike.KGauss(h,y,x)-cons
arg[arg>700]=700
f=exp(arg)*Prior
f
}
logmarg.kern=function(y,x,prior=1){
out=optim(.4,loglike.KGauss,method="L-BFGS-B",lower=.0001,upper=5,y=y,x=x)
h=out$par
cons=-out$val
stat=integrate(integrand.Gauss,lower=0.0001,upper=5,y=y,x=x,cons=cons,prior=prior)$val
list(h,cons+log(stat))
}
#Code supplied by Dr. Hart
logmarg.kern(X1,X2,prior=1)
log(sum(exp(prodlist1)))
prodlist1
exp(prodlist1)
explist <- exp(prodlist)
explist <- exp(prodlist1)
explist<10^(-320
)
sum(explist<10^(-320))
explist
explist[explist < (10)^(-320)] = 10^(-320)
explist
log(sum(explist))
?logSumExp
logSumExp(prodlist1)
k1 <- 7
K2 <- 10
n <- 20
(k1+k2)^n
(k1*k2)^n
k1 <- 7
k2 <- 10
n <- 20
(k1+k2)^n
(k1*k2)^n
k1 <- 7
k2 <- 10
n1 <- 20
n2 <- 20
(k1+k2)^(n1 + n2)
(k1^n1*k2^n2)
?beta
beta(1:100,1:100)
plot(1/beta(1:100,1:100),1:100)
plot(-lbeta(1:100,1:100),1:100)
normdraw <- rnorm(1000)
?rnorm
normdraw <- rnorm(1000)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(mean = 3, sd = .5)*(unifdraw > 0.5) + rnorm(mean = 3, sd = .5)*(unifdraw <= 0.5)
normdraw <- rnorm(1000)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = .5)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = .5)*(unifdraw <= 0.5)
set.seed(1000)
normdraw <- rnorm(1000)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = .5)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = .5)*(unifdraw <= 0.5)
var(mixturenormdraw)
set.seed(1000)
normdraw <- rnorm(1000,sd = sqrt(10))
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(mixturenormdraw)
var(unifdraw)
set.seed(1000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(mixturenormdraw)
var(normdraw)
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
var(normdraw)
var(mixturenormdraw)
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
ExpectedKernML <- logmarg.kern(XT1,XV1)
FullKernML <- logmarg.kern(c(XT1,XT2),XV1)
LBF[D] <- FullKernML[[2]] - ExpectedKernML[[2]]
logmarg.kern=function(y,x,prior=1){
out=optim(.4,loglike.KGauss,method="L-BFGS-B",lower=.0001,upper=5,y=y,x=x)
h=out$par
cons=-out$val
stat=integrate(integrand.Gauss,lower=0.0001,upper=5,y=y,x=x,cons=cons,prior=prior)$val
list(h,cons+log(stat))
}
loglike.KGauss=function(h,y,x){
n=length(x)
m=length(y)
nh=length(h)
M=t(matrix(y,m,n))
llike=1:nh
for(j in 1:nh){
M1=(x-M)/h[j]
M1=dnorm(M1)/h[j]
fhat=as.vector(M1 %*% matrix(1,m,1))/m
fhat[fhat<10^(-320)]=10^(-320)
llike[j]=sum(log(fhat))
}
-llike
}
integrand.Gauss=function(h,y,x,cons,prior){
n=length(x)
R=quantile(y,probs=c(.25,.75))
R=R[2]-R[1]
beta=R/1.35
beta1=beta*log(2)/sqrt(qgamma(.5,.5,1))
Prior=beta1*exp(-beta1/h)/h^2
if(prior==1) Prior=(2*beta/sqrt(pi))*h^(-2)*exp(-beta^2/h^2)
arg=-loglike.KGauss(h,y,x)-cons
arg[arg>700]=700
f=exp(arg)*Prior
f
}
ExpectedKernML <- logmarg.kern(XT1,XV1)
FullKernML <- logmarg.kern(c(XT1,XT2),XV1)
LBF[D] <- FullKernML[[2]] - ExpectedKernML[[2]]
ExpectedKernML <- logmarg.kern(XT1,XV1)
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
set.seed(10000)
normdraw <- rnorm(10000,sd = 1)
unifdraw <- runif(10000)
mixturenormdraw <- rnorm(10000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 10000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3))]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3))]
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)
ExpectedKernML2 <- logmarg.kern(XT2,XV2)
ExpectedKernML
ExpectedKernML2
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
source("MarginalLikIntfunctions.R")
source("MarginalLikIntfunctions.R")
source("MarginalLikIntfunctions.R")
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
source("MarginalLikIntfunctions.R")
ExpectedKernML <- logmarg.kern(XT1,XV1)
ExpectedKernML2 <- logmarg.kern(XT2,XV2)
FullKernML <- logmarg.kern(c(XT1,XT2),XV1)
LBF[D] <- FullKernML[[2]] - ExpectedKernML[[2]]
getws
getwd
wd
getwd()
setwd("C:/Users/Naveed/Documents/NonparametricCommonDistTests")
getwd()
source("MarginalLikIntfunctions.R")
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
knitr::opts_chunk$set(echo = TRUE)
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
source("MarginalLikIntfunctions.R")
ExpectedKernML <- logmarg.kern(XT1,XV1) + logmarg.kern(XT2,XV2)
set.seed(10000)
normdraw <- rnorm(1000,sd = 1)
unifdraw <- runif(1000)
mixturenormdraw <- rnorm(1000,mean = 3, sd = 1)*(unifdraw > 0.5) + rnorm(1000,mean = 3, sd = 1)*(unifdraw <= 0.5)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- mixturenormdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
source("MarginalLikIntfunctions.R")
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
ExpectedKernML - ExpectedKernML2
?rt
set.seed(10000)
normdraw <- rnorm(1000,sd = sqrt(3))
tdraw <- rt(1000,df = 3)
var(tdraw)
var(normdraw)
set.seed(10000)
normdraw <- rnorm(1000,sd = sqrt(3))
tdraw <- rt(1000,df = 3)
dlength <- 1000
dataset1 <- normdraw
dataset2 <- tdraw
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
source("MarginalLikIntfunctions.R")
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
ExpectedKernML - ExpectedKernML2
set.seed(10000)
dlength <- 200
LBF <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
LBF[i] <- ExpectedKernML - ExpectedKernML2
}
set.seed(10000)
dlength <- 200
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
LBF[i] <- ExpectedKernML - ExpectedKernML2
LBF
LBF[1]
set.seed(10000)
dlength <- 100
LBF <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
LBF[i] <- ExpectedKernML - ExpectedKernML2
}
LBF
tryCatch(logmarg.kern(XT1,XV1)[[2]])
tryCatch(logmarg.kern(XT2,XV2)[[2]])
tryCatch(logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]])
source("MarginalLikIntfunctions.R")
set.seed(10000)
dlength <- 100
LBF <- c()
for(i in 1:100)
{
dataset1 <- rcauchy(dlength)
dataset2 <- rcauchy(dlength)
XT1 <- dataset1[1:(dlength*.3)]
XV1 <- dataset1[-(1:dlength*.3)]
XT2 <- dataset2[1:(dlength*.3)]
XV2 <- dataset2[-(1:dlength*.3)]
ExpectedKernML <- logmarg.kern(XT1,XV1)[[2]] + logmarg.kern(XT2,XV2)[[2]]
ExpectedKernML2 <- logmarg.kern(c(XT1,XT2),c(XV1,XV2))[[2]]
LBF[i] <- ExpectedKernML - ExpectedKernML2
}
plot(LBF)
